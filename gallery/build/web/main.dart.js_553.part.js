// Generated by dart2js (NullSafetyMode.sound, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.5.0-167.0.dev.
((s, d, e) => {
  s[d] = s[d] || {};
  s[d][e] = s[d][e] || [];
  s[d][e].push({p: "main.dart.js_553", e: "beginPart"});
})(self, "$__dart_deferred_initializers__", "eventLog");
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var J, A, C,
  B = {
    TabController$(animationDuration, initialIndex, $length, vsync) {
      return new B.TabController(A.AnimationController$unbounded(null, initialIndex, vsync), C.Duration_300000, $length, initialIndex, initialIndex, $.$get$ChangeNotifier__emptyListeners());
    },
    DefaultTabController_maybeOf(context) {
      var t1 = context.dependOnInheritedWidgetOfExactType$1$0(type$._TabControllerScope);
      return t1 == null ? null : t1.controller;
    },
    TabController: function TabController(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._tab_controller$_animationController = t0;
      _._animationDuration = t1;
      _.length = t2;
      _._tab_controller$_index = t3;
      _._previousIndex = t4;
      _.ChangeNotifier__count = _._indexIsChangingCount = 0;
      _.ChangeNotifier__listeners = t5;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
      _.ChangeNotifier__debugDisposed = false;
    },
    TabController__changeIndex_closure: function TabController__changeIndex_closure(t0) {
      this.$this = t0;
    },
    UnderlineTabIndicator: function UnderlineTabIndicator(t0, t1, t2) {
      this.borderRadius = t0;
      this.borderSide = t1;
      this.insets = t2;
    },
    _UnderlinePainter: function _UnderlinePainter(t0, t1, t2) {
      this.decoration = t0;
      this.borderRadius = t1;
      this.onChanged = t2;
    },
    _TabStyle$(animation, child, defaults, isPrimary, isSelected, labelColor, labelStyle, unselectedLabelColor, unselectedLabelStyle) {
      return new B._TabStyle(labelStyle, unselectedLabelStyle, isSelected, labelColor, unselectedLabelColor, defaults, child, animation, null);
    },
    _TabLabelBarRenderer$(crossAxisAlignment, direction, mainAxisAlignment, mainAxisSize, onPerformLayout, textDirection, verticalDirection) {
      var i, _null = null,
        t1 = A.LayerHandle$(type$.ClipRectLayer),
        _list = J.JSArray_JSArray$allocateFixed(4, type$.TextPainter);
      for (i = 0; i < 4; ++i)
        _list[i] = new A.TextPainter(_null, C.TextAlign_4, C.TextDirection_1, C._LinearTextScaler_1.$eq(0, C._LinearTextScaler_1) ? new A._LinearTextScaler(1) : C._LinearTextScaler_1, _null, _null, _null, _null, C.TextWidthBasis_0, _null);
      t1 = new B._TabLabelBarRenderer(onPerformLayout, direction, mainAxisAlignment, mainAxisSize, crossAxisAlignment, textDirection, verticalDirection, _null, C.Clip_0, t1, _list, true, 0, _null, _null, new A._LayoutCacheStorage(), A.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      t1.addAll$1(0, _null);
      return t1;
    },
    _indexChangeProgress(controller) {
      var previousIndex, currentIndex,
        t1 = controller.get$animation(0).__AnimationController__value_A;
      t1 === $ && A.throwLateFieldNI("_value");
      previousIndex = controller._previousIndex;
      currentIndex = controller._tab_controller$_index;
      if (controller._indexIsChangingCount === 0)
        return A.clampDouble(Math.abs(currentIndex - t1), 0, 1);
      return Math.abs(t1 - currentIndex) / Math.abs(currentIndex - previousIndex);
    },
    TabBar$(controller, indicator, indicatorColor, isScrollable, labelColor, labelPadding, labelStyle, onTap, physics, tabs, unselectedLabelColor) {
      return new B.TabBar(tabs, controller, isScrollable, indicatorColor, indicator, labelColor, unselectedLabelColor, labelStyle, labelPadding, onTap, physics, null);
    },
    TabBarView$(children, controller, physics) {
      return new B.TabBarView(controller, children, physics, null);
    },
    _TabsPrimaryDefaultsM3_indicatorWeight(indicatorSize) {
      var t1;
      switch (indicatorSize.index) {
        case 1:
          t1 = 3;
          break;
        case 0:
          t1 = 2;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    TabBarIndicatorSize: function TabBarIndicatorSize(t0, t1) {
      this.index = t0;
      this._core$_name = t1;
    },
    TabAlignment: function TabAlignment(t0, t1) {
      this.index = t0;
      this._core$_name = t1;
    },
    _TabStyle: function _TabStyle(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.labelStyle = t0;
      _.unselectedLabelStyle = t1;
      _.isSelected = t2;
      _.labelColor = t3;
      _.unselectedLabelColor = t4;
      _.defaults = t5;
      _.child = t6;
      _.listenable = t7;
      _.key = t8;
    },
    _TabStyle__resolveWithLabelColor_closure: function _TabStyle__resolveWithLabelColor_closure(t0, t1) {
      this._box_0 = t0;
      this.animation = t1;
    },
    _TabLabelBarRenderer: function _TabLabelBarRenderer(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) {
      var _ = this;
      _.onPerformLayout = t0;
      _._direction = t1;
      _._mainAxisAlignment = t2;
      _._mainAxisSize = t3;
      _._crossAxisAlignment = t4;
      _._flex$_textDirection = t5;
      _._verticalDirection = t6;
      _._flex$_textBaseline = t7;
      _._flex$_overflow = 0;
      _._clipBehavior = t8;
      _._clipRectLayer = t9;
      _.DebugOverflowIndicatorMixin__indicatorLabel = t10;
      _.DebugOverflowIndicatorMixin__overflowReportNeeded = t11;
      _.ContainerRenderObjectMixin__childCount = t12;
      _.ContainerRenderObjectMixin__firstChild = t13;
      _.ContainerRenderObjectMixin__lastChild = t14;
      _._layoutCacheStorage = t15;
      _._computingThisDryBaseline = _._computingThisDryLayout = false;
      _._box$_size = null;
      _._debugActivePointers = 0;
      _._debugDisposed = false;
      _.parentData = null;
      _._depth = 0;
      _.debugCreator = _._object$_parent = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._object$_owner = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t16;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    _TabLabelBar: function _TabLabelBar(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.onPerformLayout = t0;
      _.direction = t1;
      _.mainAxisAlignment = t2;
      _.mainAxisSize = t3;
      _.crossAxisAlignment = t4;
      _.textDirection = t5;
      _.verticalDirection = t6;
      _.textBaseline = t7;
      _.children = t8;
      _.key = t9;
    },
    _DividerPainter: function _DividerPainter(t0, t1, t2) {
      this.dividerColor = t0;
      this.dividerHeight = t1;
      this._repaint = t2;
    },
    _IndicatorPainter: function _IndicatorPainter(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.controller = t0;
      _.indicator = t1;
      _.indicatorSize = t2;
      _.indicatorPadding = t3;
      _.tabKeys = t4;
      _.labelPaddings = t5;
      _.dividerColor = t6;
      _.dividerHeight = t7;
      _.showDivider = t8;
      _.devicePixelRatio = t9;
      _._tabs$_painter = _._currentRect = _._currentTextDirection = _._currentTabOffsets = null;
      _._tabs$_needsPaint = false;
      _.___IndicatorPainter__stretchAnimation_FI = $;
      _._repaint = t10;
    },
    _ChangeAnimation: function _ChangeAnimation(t0) {
      this.controller = t0;
    },
    _DragAnimation: function _DragAnimation(t0, t1) {
      this.controller = t0;
      this.index = t1;
    },
    _TabBarScrollPosition: function _TabBarScrollPosition(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.tabBar = t0;
      _._viewportDimensionWasNonZero = false;
      _._needsPixelsCorrection = true;
      _._heldPreviousVelocity = 0;
      _._userScrollDirection = t1;
      _._currentDrag = null;
      _.physics = t2;
      _.context = t3;
      _.keepScrollOffset = t4;
      _.debugLabel = t5;
      _._maxScrollExtent = _._minScrollExtent = null;
      _._impliedVelocity = 0;
      _._viewportDimension = _._pixels = null;
      _._haveDimensions = false;
      _._didChangeViewportDimensionOrReceiveCorrection = true;
      _._pendingDimensions = false;
      _._scroll_position$_lastMetrics = null;
      _._haveScheduledUpdateNotification = false;
      _._semanticActions = _._lastAxis = null;
      _.isScrollingNotifier = t6;
      _._activity = null;
      _.ChangeNotifier__count = 0;
      _.ChangeNotifier__listeners = t7;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
      _.ChangeNotifier__debugDisposed = false;
    },
    _TabBarScrollController: function _TabBarScrollController(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.tabBar = t0;
      _._initialScrollOffset = t1;
      _.onAttach = t2;
      _.onDetach = t3;
      _._positions = t4;
      _.ChangeNotifier__count = 0;
      _.ChangeNotifier__listeners = t5;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
      _.ChangeNotifier__debugDisposed = false;
    },
    TabBar: function TabBar(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.tabs = t0;
      _.controller = t1;
      _.isScrollable = t2;
      _.indicatorColor = t3;
      _.indicator = t4;
      _.labelColor = t5;
      _.unselectedLabelColor = t6;
      _.labelStyle = t7;
      _.labelPadding = t8;
      _.onTap = t9;
      _.physics = t10;
      _.key = t11;
    },
    _TabBarState: function _TabBarState(t0) {
      var _ = this;
      _._currentIndex = _._indicatorPainter = _._tabs$_controller = _._tabs$_scrollController = null;
      _.___TabBarState__labelPaddings_A = _.___TabBarState__tabKeys_A = _.___TabBarState__tabStripWidth_A = $;
      _._debugHasScheduledValidTabsCountCheck = false;
      _._widget = null;
      _._debugLifecycleState = t0;
      _._framework$_element = null;
    },
    _TabBarState_initState_closure: function _TabBarState_initState_closure() {
    },
    _TabBarState__handleTabControllerTick_closure: function _TabBarState__handleTabControllerTick_closure() {
    },
    _TabBarState_build_closure: function _TabBarState_build_closure(t0, t1) {
      this.$this = t0;
      this.tabBarTheme = t1;
    },
    _TabBarState_build_closure0: function _TabBarState_build_closure0(t0, t1) {
      this.$this = t0;
      this.selectedState = t1;
    },
    _TabBarState_build_closure1: function _TabBarState_build_closure1(t0, t1) {
      this.$this = t0;
      this.index = t1;
    },
    TabBarView: function TabBarView(t0, t1, t2, t3) {
      var _ = this;
      _.controller = t0;
      _.children = t1;
      _.physics = t2;
      _.key = t3;
    },
    _TabBarViewState: function _TabBarViewState(t0) {
      var _ = this;
      _._pageController = _._tabs$_controller = null;
      _.___TabBarViewState__childrenWithKey_A = $;
      _._currentIndex = null;
      _._scrollUnderwayCount = _._warpUnderwayCount = 0;
      _._debugHasScheduledValidChildrenCountCheck = false;
      _._widget = null;
      _._debugLifecycleState = t0;
      _._framework$_element = null;
    },
    _TabBarViewState__warpToAdjacentTab_closure: function _TabBarViewState__warpToAdjacentTab_closure(t0) {
      this.$this = t0;
    },
    _TabBarViewState__warpToNonAdjacentTab_closure: function _TabBarViewState__warpToNonAdjacentTab_closure(t0, t1, t2) {
      this.$this = t0;
      this.initialPage = t1;
      this.previousIndex = t2;
    },
    _TabBarViewState__warpToNonAdjacentTab_closure0: function _TabBarViewState__warpToNonAdjacentTab_closure0(t0) {
      this.$this = t0;
    },
    _TabsPrimaryDefaultsM3: function _TabsPrimaryDefaultsM3(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) {
      var _ = this;
      _.context = t0;
      _.___TabsPrimaryDefaultsM3__textTheme_FI = _.___TabsPrimaryDefaultsM3__colors_FI = $;
      _.isScrollable = t1;
      _.indicator = t2;
      _.indicatorColor = t3;
      _.indicatorSize = t4;
      _.dividerColor = t5;
      _.dividerHeight = t6;
      _.labelColor = t7;
      _.labelPadding = t8;
      _.labelStyle = t9;
      _.unselectedLabelColor = t10;
      _.unselectedLabelStyle = t11;
      _.overlayColor = t12;
      _.splashFactory = t13;
      _.mouseCursor = t14;
      _.tabAlignment = t15;
      _.textScaler = t16;
    },
    _TabsPrimaryDefaultsM3_overlayColor_closure: function _TabsPrimaryDefaultsM3_overlayColor_closure(t0) {
      this.$this = t0;
    },
    __ChangeAnimation_Animation_AnimationWithParentMixin: function __ChangeAnimation_Animation_AnimationWithParentMixin() {
    },
    __DragAnimation_Animation_AnimationWithParentMixin: function __DragAnimation_Animation_AnimationWithParentMixin() {
    },
    KeyedSubtree_ensureUniqueKeysForList(items) {
      var t1, t2, t3, t4, t5, t6, _0_1, _0_2, item, i, _null = null;
      if (items.length === 0)
        return items;
      t1 = A._setArrayType([], type$.JSArray_Widget);
      for (t2 = E.IndexedIterable_IndexedIterable(items, 0, type$.Widget), t3 = J.get$iterator$ax(t2._source), t4 = t2._start, t2 = new E.IndexedIterator(t3, t4, A._instanceType(t2)._eval$1("IndexedIterator<1>")), t5 = type$.ValueKey_Object; t2.moveNext$0();) {
        t6 = t2.__internal$_index;
        t6 = t6 >= 0 ? new A._Record_2(t4 + t6, t3.get$current(t3)) : A.throwExpression(A.IterableElementError_noElement());
        _0_1 = t6._0;
        _0_2 = t6._1;
        item = _0_2;
        i = _0_1;
        if (typeof i !== "number")
          return A.iae(i);
        t6 = item.key;
        if (t6 == null)
          t6 = i;
        t1.push(new A.KeyedSubtree(item, new A.ValueKey(t6, t5)));
      }
      return t1;
    }
  },
  D, E, F;
  J = holdersList[1];
  A = holdersList[0];
  C = holdersList[2];
  B = hunkHelpers.updateHolder(holdersList[109], B);
  D = holdersList[141];
  E = holdersList[110];
  F = holdersList[118];
  B.TabController.prototype = {
    _copyWithAndDispose$4$animationDuration$index$length$previousIndex(animationDuration, index, $length, previousIndex) {
      var t2, t3, _this = this,
        t1 = index == null;
      if (!t1)
        _this._tab_controller$_animationController.set$value(0, index);
      t1 = t1 ? _this._tab_controller$_index : index;
      t2 = _this._tab_controller$_animationController;
      t3 = $.$get$ChangeNotifier__emptyListeners();
      _this._tab_controller$_animationController = null;
      _this.dispose$0();
      return new B.TabController(t2, _this._animationDuration, $length, t1, previousIndex, t3);
    },
    get$animation(_) {
      var t1 = this._tab_controller$_animationController;
      return t1 == null ? null : t1;
    },
    _changeIndex$3$curve$duration(value, curve, duration) {
      var t2, _this = this,
        t1 = _this._tab_controller$_index;
      if (value === t1 || _this.length < 2)
        return;
      _this._previousIndex = t1;
      _this._tab_controller$_index = value;
      t1 = duration != null && duration._duration > 0;
      t2 = _this._indexIsChangingCount + 1;
      if (t1) {
        _this._indexIsChangingCount = t2;
        _this.notifyListeners$0();
        t1 = _this._tab_controller$_animationController;
        t1.toString;
        t2 = _this._tab_controller$_index;
        curve.toString;
        t1._animation_controller$_direction = C._AnimationDirection_0;
        t1._animateToInternal$3$curve$duration(t2, curve, duration).whenCompleteOrCancel$1(new B.TabController__changeIndex_closure(_this));
      } else {
        _this._indexIsChangingCount = t2;
        _this._tab_controller$_animationController.set$value(0, value);
        --_this._indexIsChangingCount;
        _this.notifyListeners$0();
      }
    },
    _changeIndex$1(value) {
      return this._changeIndex$3$curve$duration(value, null, null);
    },
    animateTo$2$duration(value, duration) {
      this._changeIndex$3$curve$duration(value, C.Cubic_WKj, duration == null ? this._animationDuration : duration);
    },
    animateTo$1(value) {
      return this.animateTo$2$duration(value, null);
    },
    set$offset(_, value) {
      var t3,
        t1 = this._tab_controller$_animationController,
        t2 = t1.__AnimationController__value_A;
      t2 === $ && A.throwLateFieldNI("_value");
      t3 = this._tab_controller$_index;
      if (value === t2 - t3)
        return;
      t1.set$value(0, value + t3);
    },
    dispose$0() {
      var t1 = this._tab_controller$_animationController;
      if (t1 != null)
        t1.dispose$0();
      this._tab_controller$_animationController = null;
      this.super$ChangeNotifier$dispose();
    },
    get$length(receiver) {
      return this.length;
    }
  };
  B.UnderlineTabIndicator.prototype = {
    lerpFrom$2(a, t) {
      var t1, t2;
      if (a instanceof B.UnderlineTabIndicator) {
        t1 = A.BorderSide_lerp(a.borderSide, this.borderSide, t);
        t2 = A.EdgeInsetsGeometry_lerp(a.insets, this.insets, t);
        t2.toString;
        return new B.UnderlineTabIndicator(null, t1, t2);
      }
      return this.super$Decoration$lerpFrom(a, t);
    },
    lerpTo$2(b, t) {
      var t1, t2;
      if (b instanceof B.UnderlineTabIndicator) {
        t1 = A.BorderSide_lerp(this.borderSide, b.borderSide, t);
        t2 = A.EdgeInsetsGeometry_lerp(this.insets, b.insets, t);
        t2.toString;
        return new B.UnderlineTabIndicator(null, t1, t2);
      }
      return this.super$Decoration$lerpTo(b, t);
    },
    createBoxPainter$1(onChanged) {
      return new B._UnderlinePainter(this, this.borderRadius, type$.nullable_void_Function._as(onChanged));
    },
    _indicatorRectFor$2(rect, textDirection) {
      var indicator = this.insets.resolve$1(textDirection).deflateRect$1(rect),
        t1 = indicator.left,
        t2 = this.borderSide.width,
        t3 = indicator.bottom - t2;
      return new A.Rect(t1, t3, t1 + (indicator.right - t1), t3 + t2);
    },
    getClipPath$2(rect, textDirection) {
      var t2,
        t1 = this.borderRadius;
      if (t1 != null) {
        t2 = $.$get$_renderer().createPath$0();
        t2.addRRect$1(t1.toRRect$1(this._indicatorRectFor$2(rect, textDirection)));
        return t2;
      }
      t1 = $.$get$_renderer().createPath$0();
      t1.addRect$1(this._indicatorRectFor$2(rect, textDirection));
      return t1;
    }
  };
  B._UnderlinePainter.prototype = {
    paint$3(canvas, offset, configuration) {
      var t4, paint, indicator,
        t1 = configuration.size,
        t2 = offset._dx,
        t3 = offset._dy,
        rect = new A.Rect(t2, t3, t2 + t1._dx, t3 + t1._dy);
      t1 = configuration.textDirection;
      t1.toString;
      t2 = this.borderRadius;
      t3 = this.decoration;
      t4 = t3.borderSide;
      if (t2 != null) {
        paint = $.$get$_renderer().createPaint$0();
        paint.set$color(0, t4.color);
        indicator = t3._indicatorRectFor$2(rect, t1);
        t1 = t2.topLeft;
        t3 = t2.topRight;
        t4 = t2.bottomRight;
        canvas.drawRRect$2(A.RRect$fromRectAndCorners(indicator, t2.bottomLeft, t4, t1, t3), paint);
      } else {
        paint = t4.toPaint$0();
        paint.set$strokeCap(C.StrokeCap_2);
        indicator = t3._indicatorRectFor$2(rect, t1).inflate$1(-(t4.width / 2));
        t1 = indicator.bottom;
        canvas.drawLine$3(new A.Offset(indicator.left, t1), new A.Offset(indicator.right, t1), paint);
      }
    }
  };
  B.TabBarIndicatorSize.prototype = {
    _enumToString$0() {
      return "TabBarIndicatorSize." + this._core$_name;
    }
  };
  B.TabAlignment.prototype = {
    _enumToString$0() {
      return "TabAlignment." + this._core$_name;
    }
  };
  B._TabStyle.prototype = {
    _resolveWithLabelColor$1(context) {
      var tabBarTheme, animation, t2, selectedColor, unselectedColor, _this = this, _null = null, t1 = {};
      A.Theme_of(context);
      tabBarTheme = A.Theme_of(context).tabBarTheme;
      animation = type$.Animation_double._as(_this.listenable);
      t2 = _this.labelColor;
      if (t2 == null)
        t2 = tabBarTheme.labelColor;
      if (t2 == null) {
        t2 = _this.labelStyle;
        t2 = t2 == null ? _null : t2.color;
      }
      if (t2 == null) {
        t2 = tabBarTheme.labelStyle;
        t2 = t2 == null ? _null : t2.color;
        selectedColor = t2;
      } else
        selectedColor = t2;
      if (selectedColor == null)
        selectedColor = _this.defaults.get$labelColor();
      t1.selectedColor = selectedColor;
      t1.unselectedColor = null;
      if (selectedColor instanceof A._WidgetStateColor) {
        t2 = type$.Set_WidgetState;
        t1.unselectedColor = selectedColor._resolve.call$1(t2._as(C.Set_empty));
        t1.selectedColor = selectedColor._resolve.call$1(t2._as(D.Set_23h));
      } else {
        t2 = _this.unselectedLabelColor;
        if (t2 == null)
          t2 = tabBarTheme.unselectedLabelColor;
        if (t2 == null)
          t2 = _null;
        if (t2 == null) {
          t2 = tabBarTheme.unselectedLabelStyle;
          t2 = t2 == null ? _null : t2.color;
          unselectedColor = t2;
        } else
          unselectedColor = t2;
        if (unselectedColor == null) {
          t2 = _this.defaults.get$unselectedLabelColor();
          t2.toString;
          unselectedColor = t2;
        }
        t1.unselectedColor = unselectedColor;
      }
      return A._WidgetStateColor$(new B._TabStyle__resolveWithLabelColor_closure(t1, animation));
    },
    build$1(context) {
      var selectedStyle, unselectedStyle, textStyle, _this = this, _null = null,
        tabBarTheme = A.Theme_of(context).tabBarTheme,
        animation = type$.Animation_double._as(_this.listenable),
        t1 = _this.isSelected,
        states = t1 ? D.Set_23h : C.Set_empty,
        t2 = _this.labelStyle,
        t3 = t2 == null ? tabBarTheme.labelStyle : t2;
      if (t3 == null) {
        t3 = _this.defaults.get$labelStyle();
        t3.toString;
      }
      selectedStyle = t3.copyWith$1$inherit(true);
      t3 = tabBarTheme.unselectedLabelStyle;
      t2 = t3 == null ? t2 : t3;
      if (t2 == null) {
        t2 = _this.defaults.get$unselectedLabelStyle();
        t2.toString;
      }
      unselectedStyle = t2.copyWith$1$inherit(true);
      if (t1) {
        t1 = A.TextStyle_lerp(selectedStyle, unselectedStyle, animation.get$value(animation));
        t1.toString;
        textStyle = t1;
      } else {
        t1 = A.TextStyle_lerp(unselectedStyle, selectedStyle, animation.get$value(animation));
        t1.toString;
        textStyle = t1;
      }
      t1 = _this._resolveWithLabelColor$1(context)._resolve.call$1(type$.Set_WidgetState._as(states));
      t2 = textStyle.copyWith$1$color(t1);
      return A.DefaultTextStyle$(A.IconTheme_merge(_this.child, new A.IconThemeData(24, _null, _null, _null, _null, t1, _null, _null, _null)), _null, _null, C.TextOverflow_0, true, t2, _null, _null, C.TextWidthBasis_0);
    }
  };
  B._TabLabelBarRenderer.prototype = {
    performLayout$0() {
      var child, xOffsets, t1, t2, _this = this;
      _this.super$RenderFlex$performLayout();
      child = _this.ContainerRenderObjectMixin__firstChild;
      xOffsets = A._setArrayType([], type$.JSArray_double);
      for (t1 = type$.FlexParentData; child != null;) {
        t2 = child.parentData;
        t2.toString;
        t1._as(t2);
        C.JSArray_methods.add$1(xOffsets, t2.offset._dx);
        child = t2.ContainerParentDataMixin_nextSibling;
      }
      switch (_this._flex$_textDirection.index) {
        case 0:
          C.JSArray_methods.insert$2(xOffsets, 0, _this.get$size(0)._dx);
          break;
        case 1:
          C.JSArray_methods.add$1(xOffsets, _this.get$size(0)._dx);
          break;
      }
      t1 = _this._flex$_textDirection;
      t1.toString;
      t2 = _this.get$size(0);
      _this.onPerformLayout.call$3(xOffsets, t1, t2._dx);
    },
    set$onPerformLayout(onPerformLayout) {
      this.onPerformLayout = type$.void_Function_3_List_double_and_TextDirection_and_double._as(onPerformLayout);
    }
  };
  B._TabLabelBar.prototype = {
    createRenderObject$1(context) {
      var _this = this,
        t1 = _this.getEffectiveTextDirection$1(context);
      t1.toString;
      return B._TabLabelBarRenderer$(_this.crossAxisAlignment, _this.direction, _this.mainAxisAlignment, _this.mainAxisSize, _this.onPerformLayout, t1, _this.verticalDirection);
    },
    updateRenderObject$2(context, renderObject) {
      type$._TabLabelBarRenderer._as(renderObject);
      this.super$Flex$updateRenderObject(context, renderObject);
      renderObject.set$onPerformLayout(this.onPerformLayout);
    }
  };
  B._DividerPainter.prototype = {
    paint$2(canvas, size) {
      var paint,
        t1 = this.dividerHeight;
      if (t1 <= 0)
        return;
      paint = $.$get$_renderer().createPaint$0();
      paint.set$color(0, this.dividerColor);
      paint.set$strokeWidth(t1);
      t1 = size._dy;
      canvas.drawLine$3(new A.Offset(0, t1 - paint.get$strokeWidth() / 2), new A.Offset(size._dx, t1 - paint.get$strokeWidth() / 2), paint);
    },
    shouldRepaint$1(oldDelegate) {
      type$._DividerPainter._as(oldDelegate);
      return !oldDelegate.dividerColor.$eq(0, this.dividerColor) || oldDelegate.dividerHeight !== this.dividerHeight;
    }
  };
  B._IndicatorPainter.prototype = {
    markNeedsPaint$0() {
      this._tabs$_needsPaint = true;
    },
    dispose$0() {
      var t1 = this._tabs$_painter;
      if (t1 != null)
        t1.dispose$0();
    },
    indicatorRect$2(tabBarSize, tabIndex) {
      var t1, t2, t3, t4, tabLeft, tabRight, tabWidth, insets, rect, t5, _this = this;
      switch (_this._currentTextDirection.index) {
        case 0:
          t1 = _this._currentTabOffsets;
          t2 = tabIndex + 1;
          t3 = t1.length;
          if (!(t2 >= 0 && t2 < t3))
            return A.ioore(t1, t2);
          t2 = t1[t2];
          if (!(tabIndex >= 0 && tabIndex < t3))
            return A.ioore(t1, tabIndex);
          t1 = new A._Record_2(t2, t1[tabIndex]);
          break;
        case 1:
          t1 = _this._currentTabOffsets;
          t2 = t1.length;
          if (!(tabIndex >= 0 && tabIndex < t2))
            return A.ioore(t1, tabIndex);
          t3 = t1[tabIndex];
          t4 = tabIndex + 1;
          if (!(t4 < t2))
            return A.ioore(t1, t4);
          t4 = new A._Record_2(t3, t1[t4]);
          t1 = t4;
          break;
        default:
          t1 = null;
      }
      tabLeft = t1._0;
      tabRight = t1._1;
      if (_this.indicatorSize === D.TabBarIndicatorSize_1) {
        t1 = _this.tabKeys;
        if (!(tabIndex >= 0 && tabIndex < t1.length))
          return A.ioore(t1, tabIndex);
        t1 = t1[tabIndex];
        tabWidth = $.WidgetsBinding__instance.WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, t1).get$size(0)._dx;
        t1 = _this.labelPaddings;
        if (!(tabIndex < t1.length))
          return A.ioore(t1, tabIndex);
        insets = t1[tabIndex].resolve$1(_this._currentTextDirection);
        tabLeft += (tabRight - tabLeft - (tabWidth + insets.get$horizontal())) / 2 + insets.left;
        tabRight = tabLeft + tabWidth;
      }
      insets = _this.indicatorPadding;
      t1 = tabLeft + (tabRight - tabLeft);
      t2 = 0 + tabBarSize._dy;
      rect = new A.Rect(tabLeft, 0, t1, t2);
      t3 = insets.get$horizontal();
      t4 = insets.get$_top(0);
      t5 = insets.get$_bottom(0);
      if (!(t1 - tabLeft >= t3 && t2 >= t4 + t5))
        throw A.wrapException(A.FlutterError_FlutterError("indicatorPadding insets should be less than Tab Size\nRect Size : " + rect.get$size(0).toString$0(0) + ", Insets: " + insets.toString$0(0)));
      return insets.deflateRect$1(rect);
    },
    paint$2(canvas, size) {
      var t2, index, ltr, t3, from, to, t4, t5, t6, dividerPaint, t7, _this = this, _null = null,
        t1 = _this._tabs$_needsPaint = false;
      if (_this._tabs$_painter == null)
        _this._tabs$_painter = _this.indicator.createBoxPainter$1(_this.get$markNeedsPaint());
      t2 = _this.controller;
      index = t2._tab_controller$_index;
      t2 = t2.get$animation(0).__AnimationController__value_A;
      t2 === $ && A.throwLateFieldNI("_value");
      ltr = index > t2;
      t3 = ltr ? C.JSNumber_methods.floor$0(t2) : C.JSNumber_methods.ceil$0(t2);
      from = C.JSInt_methods.clamp$2(t3, 0, _this._currentTabOffsets.length - 2);
      t3 = ltr ? from + 1 : from - 1;
      to = C.JSInt_methods.clamp$2(t3, 0, _this._currentTabOffsets.length - 2);
      t2 = _this._currentRect = A.Rect_lerp(_this.indicatorRect$2(size, from), _this.indicatorRect$2(size, to), Math.abs(t2 - from));
      switch (_this.indicatorSize.index) {
        case 1:
          t2.toString;
          t2 = _this._applyStretchEffect$1(t2);
          break;
        case 0:
          break;
        default:
          t2 = _null;
      }
      _this._currentRect = t2;
      t3 = t2.right;
      t4 = t2.left;
      t5 = t2.bottom;
      t2 = t2.top;
      t6 = _this._currentTextDirection;
      if (_this.showDivider) {
        t1 = _this.dividerHeight;
        t1.toString;
        t1 = t1 > 0;
      }
      if (t1) {
        dividerPaint = $.$get$_renderer().createPaint$0();
        t1 = _this.dividerColor;
        t1.toString;
        dividerPaint.set$color(0, t1);
        t1 = _this.dividerHeight;
        t1.toString;
        dividerPaint.set$strokeWidth(t1);
        t1 = size._dy;
        canvas.drawLine$3(new A.Offset(0, t1 - dividerPaint.get$strokeWidth() / 2), new A.Offset(size._dx, t1 - dividerPaint.get$strokeWidth() / 2), dividerPaint);
      }
      t1 = _this._tabs$_painter;
      t1.toString;
      t7 = _this._currentRect;
      t1.paint$3(canvas, new A.Offset(t7.left, t7.top), new A.ImageConfiguration(_null, _this.devicePixelRatio, _null, t6, new A.Size(t3 - t4, t5 - t2), _null));
    },
    _applyStretchEffect$1(rect) {
      var index, tabChangeProgress, progressLeft, tabsDelta, value, t3, t4, result, inflationPerSide, _this = this,
        t1 = _this.controller,
        t2 = t1.get$animation(0).__AnimationController__status_A;
      t2 === $ && A.throwLateFieldNI("_status");
      if (t2 === C.AnimationStatus_3)
        return rect;
      index = t1._tab_controller$_index;
      t2 = t1.get$animation(0).__AnimationController__value_A;
      t2 === $ && A.throwLateFieldNI("_value");
      tabChangeProgress = A._Cell$named("tabChangeProgress");
      progressLeft = Math.abs(index - t2);
      if (t1._indexIsChangingCount !== 0) {
        tabsDelta = Math.abs(t1._tab_controller$_index - t1._previousIndex);
        tabChangeProgress._value = 1 - A.clampDouble(tabsDelta !== 0 ? progressLeft / tabsDelta : progressLeft, 0, 1);
      } else
        tabChangeProgress._value = progressLeft;
      if (J.$eq$(tabChangeProgress._readLocal$0(), 1))
        return rect;
      t1 = rect.right;
      t2 = rect.left;
      value = _this.___IndicatorPainter__stretchAnimation_FI;
      if (value === $) {
        t3 = type$.Tween_double;
        t4 = type$.TweenSequenceItem_double;
        result = A.TweenSequence$(A._setArrayType([new A.TweenSequenceItem(new A.Tween(0, 1, t3), 20, t4), new A.TweenSequenceItem(new A.Tween(1, 0, t3), 80, t4)], type$.JSArray_TweenSequenceItem_double), type$.double);
        _this.___IndicatorPainter__stretchAnimation_FI !== $ && A.throwLateFieldADI("_stretchAnimation");
        _this.set$___IndicatorPainter__stretchAnimation_FI(result);
        value = result;
      }
      t3 = value.transform$1(0, tabChangeProgress._readLocal$0());
      if (typeof t3 !== "number")
        return A.iae(t3);
      inflationPerSide = (t1 - t2) * t3 / 2;
      return new A.Rect(t2 - inflationPerSide, rect.top, t1 + inflationPerSide, rect.bottom);
    },
    shouldRepaint$1(old) {
      var _this = this;
      type$._IndicatorPainter._as(old);
      return _this._tabs$_needsPaint || _this.controller !== old.controller || !_this.indicator.$eq(0, old.indicator) || _this.tabKeys.length !== old.tabKeys.length || !A.listEquals(_this._currentTabOffsets, old._currentTabOffsets, type$.double) || _this._currentTextDirection != old._currentTextDirection;
    },
    set$_currentTabOffsets(_currentTabOffsets) {
      this._currentTabOffsets = type$.nullable_List_double._as(_currentTabOffsets);
    },
    set$___IndicatorPainter__stretchAnimation_FI(___IndicatorPainter__stretchAnimation_FI) {
      this.___IndicatorPainter__stretchAnimation_FI = type$.Animatable_double._as(___IndicatorPainter__stretchAnimation_FI);
    }
  };
  B._ChangeAnimation.prototype = {
    get$parent(_) {
      var t1 = this.controller.get$animation(0);
      t1.toString;
      return t1;
    },
    removeStatusListener$1(listener) {
      type$.void_Function_AnimationStatus._as(listener);
      if (this.controller.get$animation(0) != null)
        this.super$AnimationWithParentMixin$removeStatusListener(listener);
    },
    removeListener$1(_, listener) {
      type$.void_Function._as(listener);
      if (this.controller.get$animation(0) != null)
        this.super$AnimationWithParentMixin$removeListener(0, listener);
    },
    get$value(_) {
      return B._indexChangeProgress(this.controller);
    }
  };
  B._DragAnimation.prototype = {
    get$parent(_) {
      var t1 = this.controller.get$animation(0);
      t1.toString;
      return t1;
    },
    removeStatusListener$1(listener) {
      type$.void_Function_AnimationStatus._as(listener);
      if (this.controller.get$animation(0) != null)
        this.super$AnimationWithParentMixin$removeStatusListener(listener);
    },
    removeListener$1(_, listener) {
      type$.void_Function._as(listener);
      if (this.controller.get$animation(0) != null)
        this.super$AnimationWithParentMixin$removeListener(0, listener);
    },
    get$value(_) {
      var t1 = this.controller,
        t2 = t1.get$animation(0).__AnimationController__value_A;
      t2 === $ && A.throwLateFieldNI("_value");
      return A.clampDouble(Math.abs(A.clampDouble(t2, 0, t1.length - 1) - this.index), 0, 1);
    }
  };
  B._TabBarScrollPosition.prototype = {
    applyContentDimensions$2(minScrollExtent, maxScrollExtent) {
      var t2, t3, t4, result, _this = this,
        t1 = _this._viewportDimensionWasNonZero;
      if (!t1) {
        t1 = _this._viewportDimension;
        t1.toString;
        t1 = _this._viewportDimensionWasNonZero = t1 !== 0;
      }
      t1 = !t1 || _this._needsPixelsCorrection;
      if (t1) {
        _this._needsPixelsCorrection = false;
        t2 = _this.tabBar;
        t3 = _this._viewportDimension;
        t3.toString;
        t4 = t2._currentIndex;
        t4.toString;
        _this._pixels = t2._tabScrollOffset$4(t4, t3, minScrollExtent, maxScrollExtent);
      }
      result = !t1;
      return _this.super$ScrollPosition$applyContentDimensions(minScrollExtent, maxScrollExtent) && result;
    }
  };
  B._TabBarScrollController.prototype = {
    createScrollPosition$3(physics, context, oldPosition) {
      var _null = null,
        t1 = $.$get$ChangeNotifier__emptyListeners();
      t1 = new B._TabBarScrollPosition(this.tabBar, C.ScrollDirection_0, physics, context, true, _null, new A.ValueNotifier(false, t1, type$.ValueNotifier_bool), t1);
      t1.ScrollPosition$5$context$debugLabel$keepScrollOffset$oldPosition$physics(context, _null, true, oldPosition, physics);
      t1.ScrollPositionWithSingleContext$6$context$debugLabel$initialPixels$keepScrollOffset$oldPosition$physics(context, _null, _null, true, oldPosition, physics);
      return t1;
    }
  };
  B.TabBar.prototype = {
    get$preferredSize() {
      var t1, t2, t3, maxHeight, _i, item;
      for (t1 = this.tabs, t2 = t1.length, t3 = type$.PreferredSizeWidget, maxHeight = 46, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i) {
        item = t1[_i];
        if (t3._is(item))
          maxHeight = Math.max(item.get$preferredSize()._dy, maxHeight);
      }
      return new A.Size(1 / 0, maxHeight + 2);
    },
    get$tabHasTextAndIcon() {
      var t1, t2, t3, _i, item;
      for (t1 = this.tabs, t2 = t1.length, t3 = type$.PreferredSizeWidget, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i) {
        item = t1[_i];
        if (t3._is(item))
          if (item.get$preferredSize()._dy === 72)
            return true;
      }
      return false;
    },
    createState$0() {
      return new B._TabBarState(C._StateLifecycle_0);
    },
    $isPreferredSizeWidget: 1
  };
  B._TabBarState.prototype = {
    initState$0() {
      var t1, t2, t3, _this = this;
      _this.super$State$initState();
      t1 = _this._widget.tabs;
      t2 = A._arrayInstanceType(t1);
      t3 = t2._eval$1("MappedListIterable<1,GlobalKey<State<StatefulWidget>>>");
      _this.set$___TabBarState__tabKeys_A(type$.List_GlobalKey_State_StatefulWidget._as(A.List_List$of(new A.MappedListIterable(t1, t2._eval$1("GlobalKey<State<StatefulWidget>>(1)")._as(new B._TabBarState_initState_closure()), t3), true, t3._eval$1("ListIterable.E"))));
      _this.set$___TabBarState__labelPaddings_A(type$.List_EdgeInsetsGeometry._as(A.List_List$filled(_this._widget.tabs.length, C.EdgeInsets_0_0_0_0, true, type$.EdgeInsetsGeometry)));
    },
    get$_tabs$_defaults() {
      var t2, _null = null,
        t1 = this._framework$_element;
      t1.toString;
      A.Theme_of(t1);
      t1 = this._widget;
      t1.toString;
      t2 = this._framework$_element;
      t2.toString;
      return new B._TabsPrimaryDefaultsM3(t2, t1.isScrollable, _null, _null, D.TabBarIndicatorSize_1, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null);
    },
    _getIndicator$1(indicatorSize) {
      var tabBarTheme, t2, color, effectiveIndicatorWeight, effectiveBorderRadius, _this = this, _null = null,
        t1 = _this._framework$_element;
      t1.toString;
      A.Theme_of(t1);
      t1 = _this._framework$_element;
      t1.toString;
      tabBarTheme = A.Theme_of(t1).tabBarTheme;
      t1 = _this._widget;
      t2 = t1.indicator;
      if (t2 != null)
        return t2;
      t2 = tabBarTheme.indicator;
      if (t2 != null)
        return t2;
      t1 = t1.indicatorColor;
      color = t1 == null ? tabBarTheme.indicatorColor : t1;
      if (color == null)
        color = _this.get$_tabs$_defaults().get$indicatorColor();
      _this._widget.toString;
      t1 = color.get$value(color);
      t2 = _this._framework$_element;
      t2.toString;
      t2 = A.LookupBoundary_findAncestorRenderObjectOfType(t2, type$._RenderInkFeatures);
      if (t2 == null)
        t2 = _null;
      else {
        t2 = t2.color;
        t2 = t2 == null ? _null : t2.get$value(t2);
      }
      t2 = t1 === t2;
      t1 = t2;
      if (t1)
        color = C.Color_4294967295;
      _this._widget.toString;
      switch (true) {
        case true:
          t1 = B._TabsPrimaryDefaultsM3_indicatorWeight(indicatorSize);
          break;
        case false:
          t1 = 2;
          break;
        default:
          t1 = _null;
      }
      effectiveIndicatorWeight = Math.max(2, A.checkNum(t1));
      switch (indicatorSize.index) {
        case 1:
          t1 = true;
          break;
        case 0:
          t1 = false;
          break;
        default:
          t1 = _null;
      }
      effectiveBorderRadius = t1 ? new A.BorderRadius(new A.Radius(effectiveIndicatorWeight, effectiveIndicatorWeight), new A.Radius(effectiveIndicatorWeight, effectiveIndicatorWeight), C.Radius_0_0, C.Radius_0_0) : _null;
      return new B.UnderlineTabIndicator(effectiveBorderRadius, new A.BorderSide(color, effectiveIndicatorWeight, C.BorderStyle_1, -1), C.EdgeInsets_0_0_0_0);
    },
    get$_controllerIsValid() {
      var t1 = this._tabs$_controller;
      return (t1 == null ? null : t1.get$animation(0)) != null;
    },
    _updateTabController$0() {
      var t1, t2, _this = this,
        newController = _this._widget.controller;
      if (newController == null) {
        t1 = _this._framework$_element;
        t1.toString;
        newController = B.DefaultTabController_maybeOf(t1);
      }
      if (newController == _this._tabs$_controller)
        return;
      if (_this.get$_controllerIsValid()) {
        _this._tabs$_controller.get$animation(0).removeListener$1(0, _this.get$_handleTabControllerAnimationTick());
        _this._tabs$_controller.removeListener$1(0, _this.get$_handleTabControllerTick());
      }
      _this._tabs$_controller = newController;
      if (newController != null) {
        t1 = newController.get$animation(0);
        t1.toString;
        t2 = type$.void_Function._as(_this.get$_handleTabControllerAnimationTick());
        t1.didRegisterListener$0();
        t1 = t1.AnimationLocalListenersMixin__listeners;
        t1.$ti._precomputed1._as(t2);
        t1._isDirty = true;
        C.JSArray_methods.add$1(t1._list, t2);
        _this._tabs$_controller.addListener$1(0, _this.get$_handleTabControllerTick());
        _this._currentIndex = _this._tabs$_controller._tab_controller$_index;
      }
    },
    _initIndicatorPainter$0() {
      var tabBarTheme, indicatorSize, oldPainter, t2, t3, t4, t5, t6, t7, t8, _this = this,
        t1 = _this._framework$_element;
      t1.toString;
      A.Theme_of(t1);
      t1 = _this._framework$_element;
      t1.toString;
      tabBarTheme = A.Theme_of(t1).tabBarTheme;
      _this._widget.toString;
      indicatorSize = tabBarTheme.indicatorSize;
      if (indicatorSize == null) {
        t1 = _this.get$_tabs$_defaults().indicatorSize;
        t1.toString;
        indicatorSize = t1;
      }
      oldPainter = _this._indicatorPainter;
      if (!_this.get$_controllerIsValid())
        t1 = null;
      else {
        t1 = _this._tabs$_controller;
        t1.toString;
        t2 = _this._getIndicator$1(indicatorSize);
        _this._widget.toString;
        t3 = _this.___TabBarState__tabKeys_A;
        t3 === $ && A.throwLateFieldNI("_tabKeys");
        t4 = _this.___TabBarState__labelPaddings_A;
        t4 === $ && A.throwLateFieldNI("_labelPaddings");
        t5 = tabBarTheme.dividerColor;
        if (t5 == null)
          t5 = _this.get$_tabs$_defaults().get$dividerColor();
        _this._widget.toString;
        t6 = _this.get$_tabs$_defaults().get$dividerHeight();
        t7 = _this._widget.isScrollable;
        t8 = _this._framework$_element;
        t8.toString;
        t1 = new B._IndicatorPainter(t1, t2, indicatorSize, C.EdgeInsets_0_0_0_0, t3, t4, t5, t6, !t7, A.InheritedModel_inheritFrom(t8, C._MediaQueryAspect_2, type$.MediaQuery).data.devicePixelRatio, t1.get$animation(0));
        if (oldPainter != null) {
          t2 = oldPainter._currentTabOffsets;
          t3 = oldPainter._currentTextDirection;
          t1.set$_currentTabOffsets(type$.nullable_List_double._as(t2));
          t1._currentTextDirection = t3;
        }
      }
      _this._indicatorPainter = t1;
      if (oldPainter != null)
        oldPainter.dispose$0();
    },
    didChangeDependencies$0() {
      this.super$State$didChangeDependencies();
      this._updateTabController$0();
      this._initIndicatorPainter$0();
    },
    didUpdateWidget$1(oldWidget) {
      var t1, t2, t3, delta, _list, n, _this = this,
        _s14_ = "_labelPaddings";
      type$.TabBar._as(oldWidget);
      _this.super$State$didUpdateWidget(oldWidget);
      t1 = _this._widget;
      if (t1.controller != oldWidget.controller) {
        _this._updateTabController$0();
        _this._initIndicatorPainter$0();
        t1 = _this._tabs$_scrollController;
        if (t1 != null && t1._positions.length !== 0) {
          t1 = C.JSArray_methods.get$single(t1._positions);
          if (t1 instanceof B._TabBarScrollPosition)
            t1._needsPixelsCorrection = true;
        }
      } else {
        if (J.$eq$(t1.indicatorColor, oldWidget.indicatorColor)) {
          _this._widget.toString;
          if (C.EdgeInsets_0_0_0_0.$eq(0, C.EdgeInsets_0_0_0_0)) {
            t1 = _this._widget.indicator;
            t1 = t1 != oldWidget.indicator;
          } else
            t1 = true;
        } else
          t1 = true;
        if (t1)
          _this._initIndicatorPainter$0();
      }
      t1 = _this._widget.tabs.length;
      t2 = _this.___TabBarState__tabKeys_A;
      t2 === $ && A.throwLateFieldNI("_tabKeys");
      t3 = t2.length;
      if (t1 > t3) {
        delta = t1 - t3;
        _list = J.JSArray_JSArray$allocateGrowable(delta, type$.GlobalKey_State_StatefulWidget);
        for (t1 = type$.LabeledGlobalKey_State_StatefulWidget, n = 0; n < delta; ++n)
          _list[n] = new A.LabeledGlobalKey(null, t1);
        C.JSArray_methods.addAll$1(t2, _list);
        t1 = _this.___TabBarState__labelPaddings_A;
        t1 === $ && A.throwLateFieldNI(_s14_);
        C.JSArray_methods.addAll$1(t1, A.List_List$filled(delta, C.EdgeInsets_0_0_0_0, false, type$.EdgeInsetsGeometry));
      } else if (t1 < t3) {
        C.JSArray_methods.removeRange$2(t2, t1, t3);
        t1 = _this.___TabBarState__labelPaddings_A;
        t1 === $ && A.throwLateFieldNI(_s14_);
        C.JSArray_methods.removeRange$2(t1, _this._widget.tabs.length, _this.___TabBarState__tabKeys_A.length);
      }
    },
    dispose$0() {
      var t1, _this = this;
      _this._indicatorPainter.dispose$0();
      if (_this.get$_controllerIsValid()) {
        _this._tabs$_controller.get$animation(0).removeListener$1(0, _this.get$_handleTabControllerAnimationTick());
        _this._tabs$_controller.removeListener$1(0, _this.get$_handleTabControllerTick());
      }
      _this._tabs$_controller = null;
      t1 = _this._tabs$_scrollController;
      if (t1 != null)
        t1.dispose$0();
      _this.super$State$dispose();
    },
    _tabScrollOffset$4(index, viewportWidth, minExtent, maxExtent) {
      var t1, t2, t3, t4, tabCenter, paddingStart, _this = this;
      if (!_this._widget.isScrollable)
        return 0;
      t1 = _this._indicatorPainter._currentTabOffsets;
      t2 = t1.length;
      if (!(index >= 0 && index < t2))
        return A.ioore(t1, index);
      t3 = t1[index];
      t4 = index + 1;
      if (!(t4 < t2))
        return A.ioore(t1, t4);
      t4 = t1[t4];
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return A.iae(t4);
      tabCenter = (t3 + t4) / 2;
      t1 = _this._framework$_element.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality);
      t1.toString;
      switch (t1.textDirection.index) {
        case 0:
          _this._widget.toString;
          t1 = _this.___TabBarState__tabStripWidth_A;
          t1 === $ && A.throwLateFieldNI("_tabStripWidth");
          tabCenter = t1 - tabCenter;
          paddingStart = 0;
          break;
        case 1:
          _this._widget.toString;
          paddingStart = 0;
          break;
        default:
          paddingStart = null;
      }
      if (typeof paddingStart !== "number")
        return A.iae(paddingStart);
      return A.clampDouble(tabCenter + paddingStart - viewportWidth / 2, minExtent, maxExtent);
    },
    _tabCenteredScrollOffset$1(index) {
      var t3,
        t1 = C.JSArray_methods.get$single(this._tabs$_scrollController._positions),
        t2 = t1._viewportDimension;
      t2.toString;
      t3 = t1._minScrollExtent;
      t3.toString;
      t1 = t1._maxScrollExtent;
      t1.toString;
      return this._tabScrollOffset$4(index, t2, t3, t1);
    },
    _scrollToControllerValue$0() {
      var leadingPosition, middlePosition, trailingPosition, index, _0_0, _0_7, _this = this,
        t1 = _this._currentIndex;
      t1.toString;
      leadingPosition = t1 > 0 ? _this._tabCenteredScrollOffset$1(t1 - 1) : null;
      t1 = _this._currentIndex;
      t1.toString;
      middlePosition = _this._tabCenteredScrollOffset$1(t1);
      t1 = _this._currentIndex;
      t1.toString;
      trailingPosition = t1 < _this._indicatorPainter._currentTabOffsets.length - 2 ? _this._tabCenteredScrollOffset$1(t1 + 1) : null;
      t1 = _this._tabs$_controller;
      index = t1._tab_controller$_index;
      t1 = t1.get$animation(0).__AnimationController__value_A;
      t1 === $ && A.throwLateFieldNI("_value");
      _0_0 = t1 - index;
      $label0$0: {
        if (-1 === _0_0 || 1 === _0_0) {
          t1 = leadingPosition == null ? middlePosition : leadingPosition;
          break $label0$0;
        }
        if (0 === _0_0) {
          t1 = middlePosition;
          break $label0$0;
        }
        _0_7 = _0_0 < 0;
        if (_0_7 && leadingPosition == null) {
          t1 = middlePosition;
          break $label0$0;
        }
        if (_0_0 > 0 && trailingPosition == null) {
          t1 = middlePosition;
          break $label0$0;
        }
        if (_0_7) {
          t1 = A.lerpDouble(middlePosition, leadingPosition, index - t1);
          t1.toString;
          break $label0$0;
        }
        t1 = A.lerpDouble(middlePosition, trailingPosition, _0_0);
        t1.toString;
        break $label0$0;
      }
      _this._tabs$_scrollController.jumpTo$1(t1);
    },
    _handleTabControllerAnimationTick$0() {
      var _this = this,
        t1 = _this._tabs$_controller;
      if (t1._indexIsChangingCount === 0 && _this._widget.isScrollable) {
        _this._currentIndex = t1._tab_controller$_index;
        _this._scrollToControllerValue$0();
      }
    },
    _handleTabControllerTick$0() {
      var offset, _this = this,
        t1 = _this._tabs$_controller._tab_controller$_index;
      if (t1 !== _this._currentIndex) {
        _this._currentIndex = t1;
        if (_this._widget.isScrollable) {
          offset = _this._tabCenteredScrollOffset$1(t1);
          _this._tabs$_scrollController.animateTo$3$curve$duration(offset, C.Cubic_WKj, C.Duration_300000);
        }
      }
      _this.setState$1(new B._TabBarState__handleTabControllerTick_closure());
    },
    _saveTabOffsets$3(tabOffsets, textDirection, width) {
      var t1;
      type$.List_double._as(tabOffsets);
      this.___TabBarState__tabStripWidth_A = width;
      t1 = this._indicatorPainter;
      if (t1 != null) {
        t1.set$_currentTabOffsets(type$.nullable_List_double._as(tabOffsets));
        t1._currentTextDirection = textDirection;
      }
    },
    _buildStyledTab$4(child, isSelected, animation, defaults) {
      var t1, t2, t3;
      type$.Animation_double._as(animation);
      t1 = this._widget;
      t2 = t1.labelColor;
      t3 = t1.unselectedLabelColor;
      return B._TabStyle$(animation, child, defaults, true, isSelected, t2, t1.labelStyle, t3, null);
    },
    build$1(context) {
      var tabBarTheme, effectiveTabAlignment, t1, wrappedTabs, t2, previousIndex, t3, t4, t5, animation, tabIndex, tabCount, t6, t7, t8, index, t9, t10, effectiveMouseCursor, defaultOverlay, t11, t12, index0, t13, tabBar, effectivePadding, dividerColor, dividerColor0, showDivider, _this = this, _null = null;
      A.Theme_of(context);
      tabBarTheme = A.Theme_of(context).tabBarTheme;
      _this._widget.toString;
      effectiveTabAlignment = _this.get$_tabs$_defaults().get$tabAlignment();
      t1 = A.Localizations_of(context, C.Type_MaterialLocalizations_EyN, type$.MaterialLocalizations);
      t1.toString;
      if (_this._tabs$_controller.length === 0) {
        _this._widget.toString;
        return A.Container$(_null, _null, C.Clip_0, _null, _null, _null, _null, 48, _null, _null, _null, _null, _null);
      }
      wrappedTabs = A.List_List$generate(_this._widget.tabs.length, new B._TabBarState_build_closure(_this, tabBarTheme), true, type$.Widget);
      t2 = _this._tabs$_controller;
      if (t2 != null) {
        previousIndex = t2._previousIndex;
        t3 = t2._indexIsChangingCount;
        t4 = _this._currentIndex;
        t5 = wrappedTabs.length;
        if (t3 !== 0) {
          animation = new B._ChangeAnimation(t2);
          t4.toString;
          if (!(t4 >= 0 && t4 < t5))
            return A.ioore(wrappedTabs, t4);
          C.JSArray_methods.$indexSet(wrappedTabs, t4, _this._buildStyledTab$4(wrappedTabs[t4], true, animation, _this.get$_tabs$_defaults()));
          if (!(previousIndex >= 0 && previousIndex < wrappedTabs.length))
            return A.ioore(wrappedTabs, previousIndex);
          C.JSArray_methods.$indexSet(wrappedTabs, previousIndex, _this._buildStyledTab$4(wrappedTabs[previousIndex], false, animation, _this.get$_tabs$_defaults()));
        } else {
          t4.toString;
          if (!(t4 >= 0 && t4 < t5))
            return A.ioore(wrappedTabs, t4);
          C.JSArray_methods.$indexSet(wrappedTabs, t4, _this._buildStyledTab$4(wrappedTabs[t4], true, new B._DragAnimation(t2, t4), _this.get$_tabs$_defaults()));
          t2 = _this._currentIndex;
          t2.toString;
          if (t2 > 0) {
            tabIndex = t2 - 1;
            t2 = _this._tabs$_controller;
            t2.toString;
            t3 = A._setArrayType([], type$.JSArray_of_void_Function_AnimationStatus);
            if (!(tabIndex < wrappedTabs.length))
              return A.ioore(wrappedTabs, tabIndex);
            C.JSArray_methods.$indexSet(wrappedTabs, tabIndex, _this._buildStyledTab$4(wrappedTabs[tabIndex], false, new A.ReverseAnimation(new B._DragAnimation(t2, tabIndex), new A.ObserverList(t3, type$.ObserverList_of_void_Function_AnimationStatus), 0), _this.get$_tabs$_defaults()));
          }
          t2 = _this._currentIndex;
          t2.toString;
          if (t2 < _this._widget.tabs.length - 1) {
            tabIndex = t2 + 1;
            t2 = _this._tabs$_controller;
            t2.toString;
            t3 = A._setArrayType([], type$.JSArray_of_void_Function_AnimationStatus);
            if (!(tabIndex >= 0 && tabIndex < wrappedTabs.length))
              return A.ioore(wrappedTabs, tabIndex);
            C.JSArray_methods.$indexSet(wrappedTabs, tabIndex, _this._buildStyledTab$4(wrappedTabs[tabIndex], false, new A.ReverseAnimation(new B._DragAnimation(t2, tabIndex), new A.ObserverList(t3, type$.ObserverList_of_void_Function_AnimationStatus), 0), _this.get$_tabs$_defaults()));
          }
        }
      }
      tabCount = _this._widget.tabs.length;
      for (t2 = type$.JSArray_Widget, t3 = tabBarTheme.overlayColor, t4 = type$._WidgetStatePropertyWith_nullable_Color, t5 = type$.nullable_MouseCursor, t6 = type$.WidgetState, t7 = effectiveTabAlignment === D.TabAlignment_2, t8 = t3 == null, index = 0; index < tabCount; index = index0) {
        t9 = A.LinkedHashSet_LinkedHashSet$_empty(t6);
        if (index === _this._currentIndex)
          t9.add$1(0, C.WidgetState_4);
        _this._widget.toString;
        t10 = A.WidgetStateProperty_resolveAs(_null, t9, t5);
        if (t10 == null)
          effectiveMouseCursor = _null;
        else
          effectiveMouseCursor = t10;
        if (effectiveMouseCursor == null)
          effectiveMouseCursor = C._EnabledAndDisabledMouseCursor_SystemMouseCursor_click_clickable.resolve$1(t9);
        defaultOverlay = new A._WidgetStatePropertyWith(new B._TabBarState_build_closure0(_this, t9), t4);
        _this._widget.toString;
        t9 = t8 ? defaultOverlay : t3;
        t10 = _this.get$_tabs$_defaults().get$splashFactory();
        _this._widget.toString;
        if (!(index < wrappedTabs.length))
          return A.ioore(wrappedTabs, index);
        t11 = wrappedTabs[index];
        t12 = _this._currentIndex;
        index0 = index + 1;
        t13 = t1.tabLabel$2$tabCount$tabIndex(tabCount, index0);
        C.JSArray_methods.$indexSet(wrappedTabs, index, A.InkWell$(false, _null, true, new A.Padding(new A.EdgeInsets(0, 0, 0, 2), new A.Stack(C.AlignmentDirectional_m1_m1, _null, C.StackFit_0, C.Clip_1, A._setArrayType([t11, new A.Semantics(new A.SemanticsProperties(_null, _null, _null, _null, _null, index === t12, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, t13, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null), false, false, false, false, _null, _null)], t2), _null), _null), _null, true, false, _null, _null, _null, _null, _null, effectiveMouseCursor, _null, _null, _null, _null, _null, new B._TabBarState_build_closure1(_this, index), _null, _null, t9, _null, _null, t10, _null));
        if (!_this._widget.isScrollable && t7) {
          if (!(index < wrappedTabs.length))
            return A.ioore(wrappedTabs, index);
          C.JSArray_methods.$indexSet(wrappedTabs, index, new A.Expanded(1, C.FlexFit_0, wrappedTabs[index], _null));
        }
      }
      t1 = _this._indicatorPainter;
      t2 = _this._widget;
      t3 = t2.labelColor;
      t4 = t2.unselectedLabelColor;
      t2 = t2.labelStyle;
      t5 = _this.get$_tabs$_defaults();
      t6 = t7 ? C.MainAxisSize_1 : C.MainAxisSize_0;
      tabBar = A.CustomPaint$(B._TabStyle$(C.C__AlwaysDismissedAnimation, new B._TabLabelBar(_this.get$_saveTabOffsets(), C.Axis_0, C.MainAxisAlignment_0, t6, C.CrossAxisAlignment_2, _null, C.VerticalDirection_1, _null, wrappedTabs, _null), t5, true, false, t3, t2, t4, _null), _null, _null, t1, C.Size_0_0);
      if (_this._widget.isScrollable) {
        if (effectiveTabAlignment === D.TabAlignment_1)
          effectivePadding = D.EdgeInsetsDirectional_52_0_0_0.add$1(0, C.EdgeInsets_0_0_0_0);
        else
          effectivePadding = _null;
        if (_this._tabs$_scrollController == null)
          _this._tabs$_scrollController = new B._TabBarScrollController(_this, 0, _null, _null, A._setArrayType([], type$.JSArray_ScrollPosition), $.$get$ChangeNotifier__emptyListeners());
        t1 = A.ScrollConfiguration_of(context).copyWith$1$overscroll(false);
        t2 = _this._widget;
        tabBar = A.ScrollConfiguration$(t1, A.SingleChildScrollView$(tabBar, C.Clip_1, _this._tabs$_scrollController, C.DragStartBehavior_1, effectivePadding, t2.physics, _null, _null, false, C.Axis_0));
        $label0$0: {
          if (D.TabAlignment_3 === effectiveTabAlignment) {
            t1 = C.Alignment_0_0;
            break $label0$0;
          }
          if (D.TabAlignment_0 === effectiveTabAlignment || D.TabAlignment_1 === effectiveTabAlignment || D.TabAlignment_2 === effectiveTabAlignment) {
            t1 = C.AlignmentDirectional_m1_0;
            break $label0$0;
          }
          t1 = _null;
        }
        dividerColor = tabBarTheme.dividerColor;
        t2 = dividerColor == null;
        if (t2) {
          t3 = _this.get$_tabs$_defaults().get$dividerColor();
          t3.toString;
          dividerColor0 = t3;
        } else
          dividerColor0 = dividerColor;
        _this._widget.toString;
        t3 = _this.get$_tabs$_defaults().get$dividerHeight();
        t3.toString;
        showDivider = !dividerColor0.$eq(0, C.Color_0) && t3 > 0;
        tabBar = new A.Align(t1, showDivider ? _null : 1, 1, tabBar, _null);
        if (showDivider) {
          _this._widget.toString;
          if (t2) {
            t1 = _this.get$_tabs$_defaults().get$dividerColor();
            t1.toString;
          } else
            t1 = dividerColor;
          _this._widget.toString;
          t2 = _this.get$_tabs$_defaults().get$dividerHeight();
          t2.toString;
          tabBar = A.CustomPaint$(tabBar, _null, _null, new B._DividerPainter(t1, t2, _null), C.Size_0_0);
        }
      }
      t1 = A.InheritedModel_inheritFrom(context, _null, type$.MediaQuery).data;
      _this._widget.toString;
      return A.MediaQuery$(tabBar, t1.copyWith$1$textScaler(tabBarTheme.textScaler));
    },
    set$___TabBarState__tabKeys_A(___TabBarState__tabKeys_A) {
      this.___TabBarState__tabKeys_A = type$.List_GlobalKey_State_StatefulWidget._as(___TabBarState__tabKeys_A);
    },
    set$___TabBarState__labelPaddings_A(___TabBarState__labelPaddings_A) {
      this.___TabBarState__labelPaddings_A = type$.List_EdgeInsetsGeometry._as(___TabBarState__labelPaddings_A);
    }
  };
  B.TabBarView.prototype = {
    createState$0() {
      return new B._TabBarViewState(C._StateLifecycle_0);
    }
  };
  B._TabBarViewState.prototype = {
    get$_controllerIsValid() {
      var t1 = this._tabs$_controller;
      return (t1 == null ? null : t1.get$animation(0)) != null;
    },
    _updateTabController$0() {
      var t1, t2, _this = this,
        newController = _this._widget.controller;
      if (newController == null) {
        t1 = _this._framework$_element;
        t1.toString;
        newController = B.DefaultTabController_maybeOf(t1);
      }
      if (newController == _this._tabs$_controller)
        return;
      if (_this.get$_controllerIsValid())
        _this._tabs$_controller.get$animation(0).removeListener$1(0, _this.get$_handleTabControllerAnimationTick());
      _this._tabs$_controller = newController;
      if (newController != null) {
        t1 = newController.get$animation(0);
        t1.toString;
        t2 = type$.void_Function._as(_this.get$_handleTabControllerAnimationTick());
        t1.didRegisterListener$0();
        t1 = t1.AnimationLocalListenersMixin__listeners;
        t1.$ti._precomputed1._as(t2);
        t1._isDirty = true;
        C.JSArray_methods.add$1(t1._list, t2);
      }
    },
    _jumpToPage$1(page) {
      ++this._warpUnderwayCount;
      this._pageController.jumpToPage$1(page);
      --this._warpUnderwayCount;
    },
    _animateToPage$3$curve$duration(page, curve, duration) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this;
      var $async$_animateToPage$3$curve$duration = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              ++$async$self._warpUnderwayCount;
              $async$goto = 2;
              return A._asyncAwait($async$self._pageController.animateToPage$3$curve$duration(page, curve, duration), $async$_animateToPage$3$curve$duration);
            case 2:
              // returning from await.
              --$async$self._warpUnderwayCount;
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_animateToPage$3$curve$duration, $async$completer);
    },
    initState$0() {
      this.super$State$initState();
      this.set$___TabBarViewState__childrenWithKey_A(type$.List_Widget._as(B.KeyedSubtree_ensureUniqueKeysForList(this._widget.children)));
    },
    didChangeDependencies$0() {
      var t1, t2, _this = this;
      _this.super$State$didChangeDependencies();
      _this._updateTabController$0();
      t1 = _this._currentIndex = _this._tabs$_controller._tab_controller$_index;
      t2 = _this._pageController;
      if (t2 == null) {
        _this._widget.toString;
        _this._pageController = A.PageController$(t1, 1);
      } else
        t2.jumpToPage$1(t1);
    },
    didUpdateWidget$1(oldWidget) {
      var t1, _this = this;
      type$.TabBarView._as(oldWidget);
      _this.super$State$didUpdateWidget(oldWidget);
      if (_this._widget.controller != oldWidget.controller) {
        _this._updateTabController$0();
        t1 = _this._tabs$_controller._tab_controller$_index;
        _this._currentIndex = t1;
        _this._jumpToPage$1(t1);
      }
      t1 = _this._widget;
      t1 = t1.children;
      if (t1 !== oldWidget.children && _this._warpUnderwayCount === 0)
        _this.set$___TabBarViewState__childrenWithKey_A(type$.List_Widget._as(B.KeyedSubtree_ensureUniqueKeysForList(t1)));
    },
    dispose$0() {
      var t1, _this = this;
      if (_this.get$_controllerIsValid())
        _this._tabs$_controller.get$animation(0).removeListener$1(0, _this.get$_handleTabControllerAnimationTick());
      _this._tabs$_controller = null;
      t1 = _this._pageController;
      if (t1 != null)
        t1.dispose$0();
      _this.super$State$dispose();
    },
    _handleTabControllerAnimationTick$0() {
      var t1, _this = this;
      if (_this._scrollUnderwayCount > 0 || _this._tabs$_controller._indexIsChangingCount === 0)
        return;
      t1 = _this._tabs$_controller._tab_controller$_index;
      if (t1 !== _this._currentIndex) {
        _this._currentIndex = t1;
        _this._warpToCurrentIndex$0();
      }
    },
    _warpToCurrentIndex$0() {
      var t1, t2, t3, _this = this;
      if (_this._framework$_element != null) {
        t1 = type$._PagePosition._as(C.JSArray_methods.get$single(_this._pageController._positions)).get$page(0);
        t2 = _this._currentIndex;
        t2.toString;
        t2 = t1 === t2;
        t1 = t2;
      } else
        t1 = true;
      if (t1)
        return;
      t1 = _this._currentIndex;
      t1.toString;
      t2 = _this._tabs$_controller;
      t3 = t2._previousIndex;
      t2 = t2._animationDuration;
      if (Math.abs(t1 - t3) === 1)
        _this._warpToAdjacentTab$1(t2);
      else
        _this._warpToNonAdjacentTab$1(t2);
    },
    _warpToAdjacentTab$1(duration) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$self = this, t1;
      var $async$_warpToAdjacentTab$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._currentIndex;
              $async$goto = duration._duration === 0 ? 3 : 5;
              break;
            case 3:
              // then
              t1.toString;
              $async$self._jumpToPage$1(t1);
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              t1.toString;
              $async$goto = 6;
              return A._asyncAwait($async$self._animateToPage$3$curve$duration(t1, C.Cubic_WKj, duration), $async$_warpToAdjacentTab$1);
            case 6:
              // returning from await.
            case 4:
              // join
              if ($async$self._framework$_element != null)
                $async$self.setState$1(new B._TabBarViewState__warpToAdjacentTab_closure($async$self));
              $async$returnValue = A.Future_Future$value(null, type$.void);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_warpToAdjacentTab$1, $async$completer);
    },
    _warpToNonAdjacentTab$1(duration) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, initialPage, previousIndex, t1;
      var $async$_warpToNonAdjacentTab$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              previousIndex = $async$self._tabs$_controller._previousIndex;
              t1 = $async$self._currentIndex;
              t1.toString;
              initialPage = t1 > previousIndex ? t1 - 1 : t1 + 1;
              $async$self.setState$1(new B._TabBarViewState__warpToNonAdjacentTab_closure($async$self, initialPage, previousIndex));
              $async$self._jumpToPage$1(initialPage);
              t1 = $async$self._currentIndex;
              $async$goto = duration._duration === 0 ? 2 : 4;
              break;
            case 2:
              // then
              t1.toString;
              $async$self._jumpToPage$1(t1);
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              t1.toString;
              $async$goto = 5;
              return A._asyncAwait($async$self._animateToPage$3$curve$duration(t1, C.Cubic_WKj, duration), $async$_warpToNonAdjacentTab$1);
            case 5:
              // returning from await.
            case 3:
              // join
              if ($async$self._framework$_element != null)
                $async$self.setState$1(new B._TabBarViewState__warpToNonAdjacentTab_closure0($async$self));
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_warpToNonAdjacentTab$1, $async$completer);
    },
    _syncControllerOffset$0() {
      var t2,
        t1 = this._tabs$_controller;
      t1.toString;
      t2 = type$._PagePosition._as(C.JSArray_methods.get$single(this._pageController._positions)).get$page(0);
      t2.toString;
      t1.set$offset(0, A.clampDouble(t2 - this._tabs$_controller._tab_controller$_index, -1, 1));
    },
    _tabs$_handleScrollNotification$1(notification) {
      var t1, t2, _this = this;
      type$.ScrollNotification._as(notification);
      if (_this._warpUnderwayCount > 0 || _this._scrollUnderwayCount > 0)
        return false;
      if (notification.ViewportNotificationMixin__depth !== 0)
        return false;
      if (!_this.get$_controllerIsValid())
        return false;
      ++_this._scrollUnderwayCount;
      t1 = type$._PagePosition._as(C.JSArray_methods.get$single(_this._pageController._positions)).get$page(0);
      t1.toString;
      if (notification instanceof A.ScrollUpdateNotification && _this._tabs$_controller._indexIsChangingCount === 0) {
        t2 = _this._tabs$_controller;
        if (Math.abs(t1 - t2._tab_controller$_index) > 1) {
          t2._changeIndex$1(C.JSNumber_methods.round$0(t1));
          _this._currentIndex = _this._tabs$_controller._tab_controller$_index;
        }
        _this._syncControllerOffset$0();
      } else if (notification instanceof A.ScrollEndNotification) {
        t2 = _this._tabs$_controller;
        t2.toString;
        t2._changeIndex$1(C.JSNumber_methods.round$0(t1));
        t1 = _this._tabs$_controller;
        _this._currentIndex = t1._tab_controller$_index;
        if (t1._indexIsChangingCount === 0)
          _this._syncControllerOffset$0();
      }
      --_this._scrollUnderwayCount;
      return false;
    },
    build$1(context) {
      var t3, _this = this,
        t1 = _this._widget,
        t2 = _this._pageController;
      t1 = t1.physics;
      t1 = t1 == null ? new A.PageScrollPhysics(C.PageScrollPhysics_null.buildParent$1(F.ClampingScrollPhysics_null)) : new A.PageScrollPhysics(C.PageScrollPhysics_null.buildParent$1(t1));
      t3 = _this.___TabBarViewState__childrenWithKey_A;
      t3 === $ && A.throwLateFieldNI("_childrenWithKey");
      return new A.NotificationListener(_this.get$_tabs$_handleScrollNotification(), new A.PageView(false, t2, t1, true, null, A.SliverChildListDelegate$(t3, true, true, true), C.DragStartBehavior_1, C.Clip_1, null), null, type$.NotificationListener_ScrollNotification);
    },
    set$___TabBarViewState__childrenWithKey_A(___TabBarViewState__childrenWithKey_A) {
      this.___TabBarViewState__childrenWithKey_A = type$.List_Widget._as(___TabBarViewState__childrenWithKey_A);
    }
  };
  B._TabsPrimaryDefaultsM3.prototype = {
    get$_tabs$_colors() {
      var t1, _this = this,
        value = _this.___TabsPrimaryDefaultsM3__colors_FI;
      if (value === $) {
        t1 = A.Theme_of(_this.context);
        _this.___TabsPrimaryDefaultsM3__colors_FI !== $ && A.throwLateFieldADI("_colors");
        value = _this.___TabsPrimaryDefaultsM3__colors_FI = t1.colorScheme;
      }
      return value;
    },
    get$_tabs$_textTheme() {
      var t1, _this = this,
        value = _this.___TabsPrimaryDefaultsM3__textTheme_FI;
      if (value === $) {
        t1 = A.Theme_of(_this.context);
        _this.___TabsPrimaryDefaultsM3__textTheme_FI !== $ && A.throwLateFieldADI("_textTheme");
        value = _this.___TabsPrimaryDefaultsM3__textTheme_FI = t1.textTheme;
      }
      return value;
    },
    get$dividerColor() {
      var t1 = this.get$_tabs$_colors(),
        t2 = t1._outlineVariant;
      if (t2 == null) {
        t2 = t1._onBackground;
        t1 = t2 == null ? t1.onSurface : t2;
      } else
        t1 = t2;
      return t1;
    },
    get$dividerHeight() {
      return 1;
    },
    get$indicatorColor() {
      return this.get$_tabs$_colors().primary;
    },
    get$labelColor() {
      return this.get$_tabs$_colors().primary;
    },
    get$labelStyle() {
      return this.get$_tabs$_textTheme().titleSmall;
    },
    get$unselectedLabelColor() {
      var t1 = this.get$_tabs$_colors(),
        t2 = t1._onSurfaceVariant;
      return t2 == null ? t1.onSurface : t2;
    },
    get$unselectedLabelStyle() {
      return this.get$_tabs$_textTheme().titleSmall;
    },
    get$overlayColor() {
      return new A._WidgetStatePropertyWith(new B._TabsPrimaryDefaultsM3_overlayColor_closure(this), type$._WidgetStatePropertyWith_nullable_Color);
    },
    get$splashFactory() {
      return A.Theme_of(this.context).splashFactory;
    },
    get$tabAlignment() {
      return this.isScrollable ? D.TabAlignment_1 : D.TabAlignment_2;
    }
  };
  B.__ChangeAnimation_Animation_AnimationWithParentMixin.prototype = {};
  B.__DragAnimation_Animation_AnimationWithParentMixin.prototype = {};
  var typesOffset = hunkHelpers.updateTypes(["~()", "~(List<double>,TextDirection,double)", "bool(ScrollNotification)"]);
  B.TabController__changeIndex_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      if (t1._tab_controller$_animationController != null) {
        --t1._indexIsChangingCount;
        t1.notifyListeners$0();
      }
    },
    $signature: 0
  };
  B._TabStyle__resolveWithLabelColor_closure.prototype = {
    call$1(states) {
      var t1, t2, _this = this;
      if (type$.Set_WidgetState._as(states).contains$1(0, C.WidgetState_4)) {
        t1 = _this._box_0;
        t2 = _this.animation;
        t2 = A.Color_lerp(t1.selectedColor, t1.unselectedColor, t2.get$value(t2));
        t2.toString;
        return t2;
      }
      t1 = _this._box_0;
      t2 = _this.animation;
      t2 = A.Color_lerp(t1.unselectedColor, t1.selectedColor, t2.get$value(t2));
      t2.toString;
      return t2;
    },
    $signature: 7
  };
  B._TabBarState_initState_closure.prototype = {
    call$1(tab) {
      type$.Widget._as(tab);
      return new A.LabeledGlobalKey(null, type$.LabeledGlobalKey_State_StatefulWidget);
    },
    $signature: 895
  };
  B._TabBarState__handleTabControllerTick_closure.prototype = {
    call$0() {
    },
    $signature: 0
  };
  B._TabBarState_build_closure.prototype = {
    call$1(index) {
      var adjustedPadding, _this = this, _null = null,
        t1 = _this.$this,
        t2 = t1._widget,
        t3 = t2.tabs;
      if (!(index < t3.length))
        return A.ioore(t3, index);
      t3 = t3[index];
      if (type$.PreferredSizeWidget._is(t3))
        if (t2.get$tabHasTextAndIcon() && t3.get$preferredSize()._dy === 46) {
          t2 = t1._widget.labelPadding;
          t3 = t2 == null;
          if (!t3 || _this.tabBarTheme.labelPadding != null) {
            if (t3) {
              t2 = _this.tabBarTheme.labelPadding;
              t2.toString;
            }
            adjustedPadding = t2.add$1(0, D.EdgeInsets_0_13_0_13);
          } else
            adjustedPadding = D.EdgeInsets_16_13_16_13;
        } else
          adjustedPadding = _null;
      else
        adjustedPadding = _null;
      t2 = t1.___TabBarState__labelPaddings_A;
      t2 === $ && A.throwLateFieldNI("_labelPaddings");
      t3 = adjustedPadding == null ? t1._widget.labelPadding : adjustedPadding;
      if (t3 == null)
        t3 = _this.tabBarTheme.labelPadding;
      C.JSArray_methods.$indexSet(t2, index, t3 == null ? C.EdgeInsets_16_0_16_0 : t3);
      t2 = t1.___TabBarState__labelPaddings_A;
      if (!(index < t2.length))
        return A.ioore(t2, index);
      t2 = t2[index];
      t3 = t1.___TabBarState__tabKeys_A;
      t3 === $ && A.throwLateFieldNI("_tabKeys");
      if (!(index < t3.length))
        return A.ioore(t3, index);
      t3 = t3[index];
      t1 = t1._widget.tabs;
      if (!(index < t1.length))
        return A.ioore(t1, index);
      return A.Center$(new A.Padding(t2, new A.KeyedSubtree(t1[index], t3), _null), 1, _null);
    },
    $signature: 896
  };
  B._TabBarState_build_closure0.prototype = {
    call$1(states) {
      var t1,
        effectiveStates = this.selectedState;
      effectiveStates.addAll$1(0, type$.Set_WidgetState._as(states));
      t1 = this.$this.get$_tabs$_defaults().get$overlayColor();
      return t1 == null ? null : t1.resolve$1(effectiveStates);
    },
    $signature: 15
  };
  B._TabBarState_build_closure1.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = this.index;
      t1._tabs$_controller.animateTo$1(t2);
      t1 = t1._widget.onTap;
      if (t1 != null)
        t1.call$1(t2);
    },
    $signature: 0
  };
  B._TabBarViewState__warpToAdjacentTab_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      t1.set$___TabBarViewState__childrenWithKey_A(type$.List_Widget._as(B.KeyedSubtree_ensureUniqueKeysForList(t1._widget.children)));
    },
    $signature: 0
  };
  B._TabBarViewState__warpToNonAdjacentTab_closure.prototype = {
    call$0() {
      var t3, t4, temp, t5,
        t1 = this.$this,
        t2 = t1.___TabBarViewState__childrenWithKey_A;
      t2 === $ && A.throwLateFieldNI("_childrenWithKey");
      t1.set$___TabBarViewState__childrenWithKey_A(type$.List_Widget._as(A.List_List$of(t2, false, type$.Widget)));
      t2 = t1.___TabBarViewState__childrenWithKey_A;
      t3 = this.initialPage;
      t4 = t2.length;
      if (!(t3 >= 0 && t3 < t4))
        return A.ioore(t2, t3);
      temp = t2[t3];
      t5 = this.previousIndex;
      if (!(t5 >= 0 && t5 < t4))
        return A.ioore(t2, t5);
      C.JSArray_methods.$indexSet(t2, t3, t2[t5]);
      C.JSArray_methods.$indexSet(t1.___TabBarViewState__childrenWithKey_A, t5, temp);
    },
    $signature: 0
  };
  B._TabBarViewState__warpToNonAdjacentTab_closure0.prototype = {
    call$0() {
      var t1 = this.$this;
      t1.set$___TabBarViewState__childrenWithKey_A(type$.List_Widget._as(B.KeyedSubtree_ensureUniqueKeysForList(t1._widget.children)));
    },
    $signature: 0
  };
  B._TabsPrimaryDefaultsM3_overlayColor_closure.prototype = {
    call$1(states) {
      var t1, _this = this;
      type$.Set_WidgetState._as(states);
      if (states.contains$1(0, C.WidgetState_4)) {
        if (states.contains$1(0, C.WidgetState_2)) {
          t1 = _this.$this.get$_tabs$_colors().primary;
          return A.Color$fromARGB(C.JSNumber_methods.round$0(25.5), t1.get$value(t1) >>> 16 & 255, t1.get$value(t1) >>> 8 & 255, t1.get$value(t1) & 255);
        }
        if (states.contains$1(0, C.WidgetState_0)) {
          t1 = _this.$this.get$_tabs$_colors().primary;
          return A.Color$fromARGB(20, t1.get$value(t1) >>> 16 & 255, t1.get$value(t1) >>> 8 & 255, t1.get$value(t1) & 255);
        }
        if (states.contains$1(0, C.WidgetState_1)) {
          t1 = _this.$this.get$_tabs$_colors().primary;
          return A.Color$fromARGB(C.JSNumber_methods.round$0(25.5), t1.get$value(t1) >>> 16 & 255, t1.get$value(t1) >>> 8 & 255, t1.get$value(t1) & 255);
        }
        return null;
      }
      if (states.contains$1(0, C.WidgetState_2)) {
        t1 = _this.$this.get$_tabs$_colors().primary;
        return A.Color$fromARGB(C.JSNumber_methods.round$0(25.5), t1.get$value(t1) >>> 16 & 255, t1.get$value(t1) >>> 8 & 255, t1.get$value(t1) & 255);
      }
      if (states.contains$1(0, C.WidgetState_0)) {
        t1 = _this.$this.get$_tabs$_colors().onSurface.value;
        return A.Color$fromARGB(20, t1 >>> 16 & 255, t1 >>> 8 & 255, t1 & 255);
      }
      if (states.contains$1(0, C.WidgetState_1)) {
        t1 = _this.$this.get$_tabs$_colors().onSurface.value;
        return A.Color$fromARGB(C.JSNumber_methods.round$0(25.5), t1 >>> 16 & 255, t1 >>> 8 & 255, t1 & 255);
      }
      return null;
    },
    $signature: 15
  };
  (function installTearOffs() {
    var _instance_0_u = hunkHelpers._instance_0u,
      _instance = hunkHelpers.installInstanceTearOff,
      _instance_1_u = hunkHelpers._instance_1u;
    _instance_0_u(B.TabController.prototype, "get$dispose", "dispose$0", 0);
    _instance_0_u(B._IndicatorPainter.prototype, "get$markNeedsPaint", "markNeedsPaint$0", 0);
    var _;
    _instance_0_u(_ = B._TabBarState.prototype, "get$_handleTabControllerAnimationTick", "_handleTabControllerAnimationTick$0", 0);
    _instance_0_u(_, "get$_handleTabControllerTick", "_handleTabControllerTick$0", 0);
    _instance(_, "get$_saveTabOffsets", 0, 3, null, ["call$3"], ["_saveTabOffsets$3"], 1, 0, 0);
    _instance_0_u(_ = B._TabBarViewState.prototype, "get$_handleTabControllerAnimationTick", "_handleTabControllerAnimationTick$0", 0);
    _instance_1_u(_, "get$_tabs$_handleScrollNotification", "_tabs$_handleScrollNotification$1", 2);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(B.TabController, A.ChangeNotifier);
    _inheritMany(A.Closure0Args, [B.TabController__changeIndex_closure, B._TabBarState__handleTabControllerTick_closure, B._TabBarState_build_closure1, B._TabBarViewState__warpToAdjacentTab_closure, B._TabBarViewState__warpToNonAdjacentTab_closure, B._TabBarViewState__warpToNonAdjacentTab_closure0]);
    _inherit(B.UnderlineTabIndicator, A.Decoration);
    _inherit(B._UnderlinePainter, A.BoxPainter);
    _inheritMany(A._Enum, [B.TabBarIndicatorSize, B.TabAlignment]);
    _inherit(B._TabStyle, A.AnimatedWidget);
    _inheritMany(A.Closure, [B._TabStyle__resolveWithLabelColor_closure, B._TabBarState_initState_closure, B._TabBarState_build_closure, B._TabBarState_build_closure0, B._TabsPrimaryDefaultsM3_overlayColor_closure]);
    _inherit(B._TabLabelBarRenderer, A.RenderFlex);
    _inherit(B._TabLabelBar, A.Flex);
    _inheritMany(A.CustomPainter, [B._DividerPainter, B._IndicatorPainter]);
    _inheritMany(A.Animation, [B.__ChangeAnimation_Animation_AnimationWithParentMixin, B.__DragAnimation_Animation_AnimationWithParentMixin]);
    _inherit(B._ChangeAnimation, B.__ChangeAnimation_Animation_AnimationWithParentMixin);
    _inherit(B._DragAnimation, B.__DragAnimation_Animation_AnimationWithParentMixin);
    _inherit(B._TabBarScrollPosition, A.ScrollPositionWithSingleContext);
    _inherit(B._TabBarScrollController, A.ScrollController);
    _inheritMany(A.StatefulWidget, [B.TabBar, B.TabBarView]);
    _inheritMany(A.State, [B._TabBarState, B._TabBarViewState]);
    _inherit(B._TabsPrimaryDefaultsM3, A.TabBarTheme);
    _mixin(B.__ChangeAnimation_Animation_AnimationWithParentMixin, A.AnimationWithParentMixin);
    _mixin(B.__DragAnimation_Animation_AnimationWithParentMixin, A.AnimationWithParentMixin);
  })();
  A._Universe_addRules(init.typeUniverse, JSON.parse('{"_TabControllerScope":{"InheritedWidget":[],"ProxyWidget":[],"Widget":[],"DiagnosticableTree":[]},"TabController":{"ChangeNotifier":[],"Listenable":[]},"UnderlineTabIndicator":{"Decoration":[]},"_UnderlinePainter":{"BoxPainter":[]},"TabBar":{"StatefulWidget":[],"PreferredSizeWidget":[],"Widget":[],"DiagnosticableTree":[]},"TabBarView":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"TabBarIndicatorSize":{"Enum":[]},"TabAlignment":{"Enum":[]},"_TabStyle":{"AnimatedWidget":[],"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_TabLabelBarRenderer":{"RenderFlex":[],"RenderBoxContainerDefaultsMixin":["RenderBox","FlexParentData"],"RenderBox":[],"ContainerRenderObjectMixin":["RenderBox","FlexParentData"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[],"ContainerRenderObjectMixin.1":"FlexParentData","ContainerRenderObjectMixin.0":"RenderBox","RenderBoxContainerDefaultsMixin.1":"FlexParentData","RenderBoxContainerDefaultsMixin.0":"RenderBox"},"_TabLabelBar":{"MultiChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"_DividerPainter":{"CustomPainter":[],"Listenable":[]},"_IndicatorPainter":{"CustomPainter":[],"Listenable":[]},"_ChangeAnimation":{"Animation":["double"],"ValueListenable":["double"],"Listenable":[]},"_DragAnimation":{"Animation":["double"],"ValueListenable":["double"],"Listenable":[]},"_TabBarScrollPosition":{"ScrollPosition":[],"ViewportOffset":[],"ChangeNotifier":[],"Listenable":[],"ScrollMetrics":[],"ScrollActivityDelegate":[]},"_TabBarScrollController":{"ScrollController":[],"ChangeNotifier":[],"Listenable":[]},"_TabBarState":{"State":["TabBar"],"State.T":"TabBar"},"_TabBarViewState":{"State":["TabBarView"],"State.T":"TabBarView"},"_TabsPrimaryDefaultsM3":{"TabBarTheme":[]}}'));
  var type$ = (function rtii() {
    var findType = A.findType;
    return {
      Animatable_double: findType("Animatable<double>"),
      Animation_double: findType("Animation<double>"),
      ClipRectLayer: findType("ClipRectLayer"),
      ContainerLayer: findType("ContainerLayer0"),
      Directionality: findType("Directionality"),
      EdgeInsetsGeometry: findType("EdgeInsetsGeometry"),
      FlexParentData: findType("FlexParentData"),
      GlobalKey_State_StatefulWidget: findType("GlobalKey<State<StatefulWidget>>"),
      JSArray_ScrollPosition: findType("JSArray<ScrollPosition>"),
      JSArray_TweenSequenceItem_double: findType("JSArray<TweenSequenceItem<double>>"),
      JSArray_Widget: findType("JSArray<Widget>"),
      JSArray_double: findType("JSArray<double>"),
      JSArray_of_void_Function_AnimationStatus: findType("JSArray<~(AnimationStatus)>"),
      LabeledGlobalKey_State_StatefulWidget: findType("LabeledGlobalKey<State<StatefulWidget>>"),
      List_EdgeInsetsGeometry: findType("List<EdgeInsetsGeometry>"),
      List_GlobalKey_State_StatefulWidget: findType("List<GlobalKey<State<StatefulWidget>>>"),
      List_Widget: findType("List<Widget>"),
      List_double: findType("List<double>"),
      MaterialLocalizations: findType("MaterialLocalizations"),
      MediaQuery: findType("MediaQuery"),
      NotificationListener_ScrollNotification: findType("NotificationListener<ScrollNotification>"),
      ObserverList_of_void_Function_AnimationStatus: findType("ObserverList<~(AnimationStatus)>"),
      PreferredSizeWidget: findType("PreferredSizeWidget"),
      ScrollNotification: findType("ScrollNotification"),
      Set_WidgetState: findType("Set<WidgetState>"),
      TabBar: findType("TabBar"),
      TabBarView: findType("TabBarView"),
      TextPainter: findType("TextPainter"),
      TweenSequenceItem_double: findType("TweenSequenceItem<double>"),
      Tween_double: findType("Tween<double>"),
      ValueKey_Object: findType("ValueKey<Object>"),
      ValueNotifier_bool: findType("ValueNotifier<bool>"),
      Widget: findType("Widget"),
      WidgetState: findType("WidgetState"),
      _DividerPainter: findType("_DividerPainter"),
      _IndicatorPainter: findType("_IndicatorPainter"),
      _PagePosition: findType("_PagePosition"),
      _RenderInkFeatures: findType("_RenderInkFeatures"),
      _TabControllerScope: findType("_TabControllerScope"),
      _TabLabelBarRenderer: findType("_TabLabelBarRenderer"),
      _WidgetStatePropertyWith_nullable_Color: findType("_WidgetStatePropertyWith<Color?>"),
      double: findType("double"),
      nullable_List_double: findType("List<double>?"),
      nullable_MouseCursor: findType("MouseCursor?"),
      nullable_void_Function: findType("~()?"),
      void: findType("~"),
      void_Function: findType("~()"),
      void_Function_3_List_double_and_TextDirection_and_double: findType("~(List<double>,TextDirection,double)"),
      void_Function_AnimationStatus: findType("~(AnimationStatus)")
    };
  })();
  (function constants() {
    D.EdgeInsetsDirectional_52_0_0_0 = new A.EdgeInsetsDirectional(52, 0, 0, 0);
    D.EdgeInsets_0_13_0_13 = new A.EdgeInsets(0, 13, 0, 13);
    D.EdgeInsets_16_13_16_13 = new A.EdgeInsets(16, 13, 16, 13);
    D.Set_23h = new A.GeneralConstantSet([C.WidgetState_4], A.findType("GeneralConstantSet<WidgetState>"));
    D.TabAlignment_0 = new B.TabAlignment(0, "start");
    D.TabAlignment_1 = new B.TabAlignment(1, "startOffset");
    D.TabAlignment_2 = new B.TabAlignment(2, "fill");
    D.TabAlignment_3 = new B.TabAlignment(3, "center");
    D.TabBarIndicatorSize_1 = new B.TabBarIndicatorSize(1, "label");
  })();
};
;
((d, h) => {
  d[h] = d.current;
  d.eventLog.push({p: "main.dart.js_553", e: "endPart", h: h});
})($__dart_deferred_initializers__, "4SxLNrByV4vr1zNwyyqzvtwqeww=");
;